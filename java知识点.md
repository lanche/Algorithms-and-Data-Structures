# java知识点

标签（空格分隔）： Java

---

1.static方法不能被覆盖，覆盖是运行动态绑定的，而static是编译时静态绑定的
2.static变量在被虚拟机装入的时候就进行初始化，而非static变量还未创建出来，故static变量不能访问非static变量
3.自动装箱/拆箱：基本数据类型和对应的对象包装类型之间转化
4.重载，同一个类里方法名相同但是参数不同
覆盖方法名、参数列表、返回类型都要相同
5.当新的对象呗创建时就会调用构造函数，构造函数名和类名相同，自己未定义构造函数编译器会自动创建一个构造函数。
6.接口和抽象类：
不同点

 - 接口所有的方法都是抽象的，而抽象类可以有非抽象方法
 - 可以实现多个接口只能继承一个抽象类
 - 接口中的变量默认都是final的，抽象类可以包含非final变量
 - 接口的方法默认为public，抽象类可以是private，protected，public的
7.值传递和引用传递：值传递一般是对基本类型的变量而言，传递的是该变量的一个副本，改变副本不影响原变量，而引用传递一般是对对象型变量而言的，传递的是该对象地址的一个副本，并不是该对象本身。所以对引用对象操作会改变原对象，一般认为Java内的传递都是值传递。
8.创建线程的三种方式
 - 继承Thread类
 - 实现Runnable接口
 - 使用Executor框架来创建线程池
 
9.线程的几种状态：
 - 新建（new）
 - 就绪（runnable）：调用了start方法之后等待CPU的分配
 - 运行（running）：
 - 阻塞（block）：等待阻塞：调用wait方法进入等待队列（释放锁），同步阻塞：要获取的对象锁被别的线程占用进入锁池，其他阻塞：调用join方法或者sleep方法（不释放锁）
 - 死亡（dead）
10.同步方法和同步代码块的区别：同步方法默认用this或者当前类class对象作为锁，同步代码块可以选择什么来加锁，要比同步方法更细颗粒度
11.监视器
12.什么是死锁：两个或者两个以上的线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁
13.如何确保n个线程可以访问n个资源同时不会导致死锁：指定获取锁的顺序，并强制线程按照指定的线程获取锁。死锁的是个必要条件：互斥条件、保持和请求条件、不可剥夺、循环等待条件
14.Java集合类框架的基本接口：
 - Collection：代表一组对象，每个元素都是他的一个子集
 - Set、List、Map
15.快速失败和安全失败：快速失败：当你在迭代一个集合的时候，如果有另一个线程正在修改你正在访问的那个集合时，就会抛出一个ConcurrentModification异常。
    在java.util包下的都是快速失败。
安全失败：你在迭代的时候会去底层集合做一个拷贝，所以你在修改上层集合的时候是不会受影响的，不会抛出ConcurrentModification异常。
    在java.util.concurrent包下的全是安全失败的。
16.HashMap的工作原理：HashMap的底层是用hash数组和单向链表实现的 ，当调用put方法是，首先计算key的hashcode，定位到合适的数组索引，然后再在该索引上的单向链表进行循环遍历用equals比较key是否存在，如果存在则用新的value覆盖原值，如果没有则向后追加。HashMap的两个重要属性是容量capacity和加载因子loadfactor，默认值分布为16和0.75，当容器中的元素个数大于 capacity*loadfactor时，容器会进行扩容resize 为2n
17.ava中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此，可能会被集合认为是相等的。而且，这两个方法也用来发现重复元素。所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。
18.HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：
HashMap允许键和值是null，而Hashtable不允许键或者值是null。
Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。
HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。
一般认为Hashtable是一个遗留的类。
19.**Array和ArrayList的区别**:Array可以包含基本类型和对象类型，而ArrayList只能包含对象类型，Array存放的一定是同种类型的元素，ArrayList不一定，前者大小固定，后者可变（初始为10），后者方法更多，频繁移动和删除时还是选用LinkedList，效率更高，
20.**ArrayList和LinkedList的区别**:ArrayList和LinkedList都实现了List接口，他们有以下的不同点：
ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。
相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。
LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。
也可以参考ArrayList vs. LinkedList。
21.**Comparable和Comparator接口是干什么的？列出它们的区别。**:comparable和comparator都是用来实现集合中元素的的比较、排序的，只是comparable是在集合内部定义的方法实现的排序，comparator是在集合外部实现的排序。
comparable是一个对象本身就已经支持自比较所需要实现的接口，（如string,interger自己就可以完成比较大小的操作，已经实现了comparable接口）
而comparator是一个专用的比较器，当这个对象不支持自我比较或者自比较函数不能满足你的要求时，你可以写一个比较器来完成两个对象之间大小的比较。
22.Arrays.sort()用于对数组排序，Collections.sort()用于对list排序。
23.一个数乘以或者除以n个2等于左移或者右移n位。
24.Java优先队列：PriorityQueue是一个基于优先级堆的无界队列，它的元素是按照自然顺序(natural order)排序的。在创建的时候，我们可以给它提供一个负责给元素排序的比较器。PriorityQueue不允许null值，因为他们没有自然顺序，或者说他们没有任何的相关联的比较器。最后，PriorityQueue不是线程安全的，入队和出队的时间复杂度是O(log(n))。
25.**HashSet和TreeSet有什么区别：** HashSet是由一个hash表来实现的，因此，它的元素是无序的。add()，remove()，contains()方法的时间复杂度是O(1)。
另一方面，TreeSet是由一个树形的结构来实现的，它里面的元素是有序的。因此，add()，remove()，contains()方法的时间复杂度是O(logn)。
26.**JVM的永久代中会发生垃圾回收么？** 垃圾回收不会发生在永久代，如果永久代满了或者是超过了临界值，会触发完全垃圾回收(Full GC)。如果你仔细查看垃圾收集器的输出信息，就会发现永久代也是被回收的。这就是为什么正确的永久代大小对避免Full GC是非常重要的原因。请参考下Java8：从永久代到元数据区。(注：Java8中已经移除了永久代，新加了一个叫做元数据区的native内存区)
27.

 
 
  
